/*
Index与气球
竞赛 1041, 题目 B

描述
可怜的Index被传送到了《气球塔防》的世界，他被递上一个飞镖枪，被迫展开了与气球的战斗。

Index可以击中任意种类的气球，而且他的射术很准，每次攻击都可以击中气球。然而这里的气球很可怕，大部分气球在被扎破后都会立刻生成新的气球，甚至有些气球需要多次攻击才能击破。具体来说，一共有以下几种气球（括号里是气球的代码，在后面的输入中会使用到）：

1. 红色气球（1）：一击可以击破，不会生成新的气球。

2. 蓝色气球（2）：一击可以击破，会生成一个红色气球。

3. 绿色气球（3）：一击可以击破，会生成一个蓝色气球。

4. 黄色气球（4）：一击可以击破，会生成一个绿色气球。

5. 粉色气球（5）：一击可以击破，会生成一个黄色气球。

6. 黑色气球（6）：一击可以击破，会生成两个粉色气球。

7. 白色气球（7）：一击可以击破，会生成两个粉色气球。

8. 紫色气球（8）：一击可以击破，会生成两个粉色气球。

9. 斑马气球（9）：一击可以击破，会生成一个黑色气球和一个白色气球。

10. 铅气球（0）：一击可以击破，会生成两个黑色气球。

11. 彩虹气球（-）：一击可以击破，会生成两个斑马气球。

12. 陶瓷气球（=）：10击才可以击破，会生成两个彩虹气球。

13. MOAB（o）：200击才可以击破，会生成四个陶瓷气球。

14. BFB（p）：700击才可以击破，会生成四个MOAB。

15. ZOMG（[）：4000击才可以击破，会生成四个BFB。

16. DDT（]）：400击才可以击破，会生成四个陶瓷气球。

17. BAD（\）：20000击才可以击破，会生成两个ZOMG和三个DDT。

给出战场上气球的清单，你需要计算Index总共需要攻击多少次才能把所有气球（包括它们生成的气球）消灭干净。

输入
仅一行一个字符串s（1<= abs(s) <= 1.2 * 10^7），由1234567890-=op[]\这些字符组成，表示Index需要击破的所有气球。

输出
仅一行一个整数，表示Index需要攻击的总次数。

样例输入
o-o
样例输出
1279
提示
本题请特别注意判断和计算的效率！否则你的程序运行时间很有可能超出限制！

判题方式
本题采用   普通判题   。判题机读入用户输出，与参考答案逐一比对，除最末空白以外所有字符都相同，则判为正确。
*/

#include <stdio.h>
#include <stdlib.h>

long long cnt(long long I[]) {
    long long *p = I + 16;
    *I += *p * 20000, *(I + 15) += *p * 3, *(I + 14) += *p * 2, p--;
    *I += *p * 400, *(I + 11) += *p * 4, p--;
    *I += *p * 4000, *(I + 13) += *p * 4, p--;
    *I += *p * 700, *(I + 12) += *p * 4, p--;
    *I += *p * 200, *(I + 11) += *p * 4, p--;
    *I += *p * 10, *(I + 10) += *p * 2, p--;
    *I += *p, *(I + 8) += *p * 2, p--;
    *I += *p, *(I + 5) += *p * 2, p--;
    *I += *p, *(I + 5) += *p, *(I + 6) += *p, p--;
    *I += *p, *(I + 4) += *p * 2, p--;
    *I += *p, *(I + 4) += *p * 2, p--;
    *I += *p, *(I + 4) += *p * 2, p--;
    *I += *p, *(I + 3) += *p, p--;
    *I += *p, *(I + 2) += *p, p--;
    *I += *p, *(I + 1) += *p, p--;
    *I += *p, *I += *p;
    return *I;
}

int main() {
    long long I[17] = {0};
    char *C = malloc(12000001 * sizeof(char));
    scanf("%s", C);
    for (char *p = C; *p; p++) {
        int a = *p - '1';
        if ((a >= 0) && (a <= 8))
            I[a]++;
        else
            switch (a) {
                case -1:
                    I[9]++;
                    break;
                case '-' - '1':
                    I[10]++;
                    break;
                case '=' - '1':
                    I[11]++;
                    break;
                case 'o' - '1':
                    I[12]++;
                    break;
                case 'p' - '1':
                    I[13]++;
                    break;
                case '[' - '1':
                    I[14]++;
                    break;
                case ']' - '1':
                    I[15]++;
                    break;
                case '\\' - '1':
                    I[16]++;
                    break;
                default:;
            }
    }
    printf("%lld\n", cnt(I));
    free(C);
    return 0;
}
