/*
Credens Justitiam II
竞赛 1040, 题目 F

描述
题目背景
        魔法少女在实现奇迹的同时，也不幸的背负了和魔女战斗的使命。每当魔法少女受到致命伤，都需要花费大量的魔力来修复肉体，从而导致魔法少女的灵魂宝石被污染。因此，一种最优的战斗策略是在魔女发动攻击前就先发制人消灭对方。

https://music.163.com/#/song?id=32364751

描述
       魔女的迷宫由无数个正方形网格组成。魔法少女初始的坐标为[x1,y1]。魔女位于坐标[x2,y2]。魔法少女在迷宫中的正面朝向必须和坐标轴平行，即只能面朝x轴正向(南),x轴负向(北),y轴正向(东),y轴负向(西)。

       魔法少女可以释放终结技Tiro Finale ，该技能可以攻击到魔法少女附近的若干个方格。

       魔女也可以发动攻击，其射程为a。

        魔法少女先行动，每一回合开始，魔法少女有四个选择，可以任意选择一个执行：
        1. 向自己的正面朝向移动一格，回合结束。
        2. 如果魔女已经位于攻击范围内，可以选择发动必杀技消灭魔女，战斗结束。
        3. 原地不动，回合结束。
        4. 原地旋转，选择一个新的朝向，旋转后仍可以执行其他行动。

       请注意，除了原地旋转外的行动，都会立即结束本回合，并轮到魔女行动。（也就是说，允许先旋转后移动/攻击，但是不允许先移动后攻击）

        随后，轮到魔女行动。魔女的行动逻辑是死板的，如下所示：
        1. 魔女首先判断魔法少女相对于魔女的距离是否处于魔女的射程范围a内，如果是，则魔法少女会立即受到魔女的攻击，战斗结束，魔法少女受到了致命伤 并掉头。
        2. 否则，魔女判断魔法少女是否处于自己的侦测范围b内，我们保证b>=a。如果不位于侦测范围内，魔女什么也不做，轮到魔法少女继续行动。
        3. 否则，魔女向接近魔法少女的方向移动一步。魔女会优先选择减小自己和魔法少女自己横坐标的距离，当横坐标距离为0时才会选择减少自己的纵坐标距离。随后轮到魔法少女继续行动。

        请问，魔法少女是否能在受到致命伤之前抢先消灭魔女？

(Image: E:\Files\C\CLionProjects\SHOJ\2023niandi1zouzousai\F\download.jpg)

输入
第一行输入一个数字t，代表一共有t组数据。

对每一组数据，第一行输入六个整数，分别为x1，y1，x2，y2，a，b。含义如上所述。

第二行输入一个正整数n，代表接下来将输入一个n行的正方形，正方形的中心点代表魔法少女所在的位置。该正方形描述了魔法少女的终结技Tiro Finale相对于魔法少女的攻击区域。我们保证n一定为奇数。需要注意的是，攻击区域会随着魔法少女朝向的改变而一同旋转（0度，90度，180度或270度)。

接下来n行，每行输入n个非空白字符。字符*代表该相对位置下的方格会被Tiro Finale攻击到，字符#代表该相对位置下的方格不会被Tiro Finale攻击到，此外，位于矩形外的方格自然也不会被攻击到。我们保证不会出现其他非空白字符，我们不保证输入中一定存在字符*。



输出
输出t行，对应t组输入数据。对于每一组输入数据，你需要回答，魔法少女是否可以在有限回合内，抢先发动攻击消灭魔女并避免受到致命伤，如果有可能，输出YES 否则，输出NO（区分大小写）。

样例输入
7
0 5 1 4 2 10
5
##*##
#####
##*##
#####
#####
1 1 1 1 1 1
3
***
*#*
***
1 1 1 1 5 5
3
###
#*#
###
0 5 0 1 2 3
5
#####
#####
**###
#####
#####
0 5 0 1 3 3
7
#######
#######
#######
*######
#######
#######
#######
0 0 2 2 1 10
5
#####
####*
#####
#####
#####
0 0 2 2 1 10
5
###*#
#####
#####
#####
#####
样例输出
YES
NO
YES
YES
NO
NO
YES
提示
我们保证，1<=t<=2000 ，0<n<50 且 n 为奇数，0<=a<=b<50 ，0<=x1,y1,x2,y2<=10^8。迷宫是无限大且没有边界的。

在本迷宫中，魔女和魔法少女之间的距离被定义为：每一步可以上下左右移动到邻近的四个方格，最少需要移动多少步才能从魔女所在的方格走到魔法少女所在的方格。

射程为0是可能的，魔法少女和魔女的坐标允许重叠。

样例解释如下：
一共七组数据：

数据一：

魔法少女初始的坐标为[0,5],魔女位于坐标[1,4]，两者之间的距离为2，魔女的射程也是2，魔法少女本回合可以攻击坐标[0,5],[0,7],[0,3],[2,5],[-2,5]，因此不可能在第一回合消灭位于坐标[1,4]的魔女。故一种合理的策略是向西移动一格到坐标[0,6]。

接下来轮到魔女行动，此时两者距离为3，大于魔女的射程2，魔女无法攻击到魔法少女，但是依然能感知到魔法少女的存在（因为3小于等于感知距离10），故魔女移动一格，魔女优先选择减小横坐标距离，故魔女移动到坐标[0,4]。

接下来轮到魔法少女行动，魔法少女当前位于[0,6]，通过改变自身的朝向，可以将输入数据调整到逆时针旋转90度的位置，然后即可发动技能消灭位于坐标[0,4]的魔女。故输出YES。

数据二：魔法少女初始的坐标为[1,1],魔女始终位于坐标[1,1]，两者之间的距离为0，魔法少女无法攻击自身所在的位置，即使逃跑也逃不出魔女的射程1，因此必死无疑。

数据三：和数据二类似，但是魔法少女可以攻击自身所在的位置，因此第一回合就可以消灭魔女。

数据四：魔法少女初始的坐标为[0,5],魔女位于坐标[0,1]。魔女无法感知到魔法少女，因此魔法少女必须放弃防守优势选择主动接近魔女。魔法少女移动一格来到坐标[0,4]，此时魔女感知到魔法少女的存在，移动一格来到[0,2]。随后魔法少女选择面朝西，向侧方发动攻击，即可成功消灭魔女。

数据五：和数据四类似，但是魔女的射程更远，魔法少女一旦主动接近魔女就会被消灭，而原地等待或远离魔女也无法消灭魔女。

数据六和数据七用于校验，不做解释。

判题方式
本题采用   普通判题   。判题机读入用户输出，与参考答案逐一比对，除最末空白以外所有字符都相同，则判为正确。
*/

#include <stdio.h>
#include <stdlib.h>

short Search(int D, int x, int y, short a, short n, int m, short *A) {
    if (D)
        if (abs(y) <= n / 2) {
            int l = abs(x) + abs(y);
            if (abs(x) > n / 2) {
                l -= abs(x) - (n / 2);
                if (D > 0)
                    x = -(n / 2);
                else
                    x = n / 2;
            }
            short *p = A + ((n / 2) - y) * n + n / 2 + x;
            for (int i = 0; (l >= a) && (i < m); l--, i++)
                if (*p)
                    return 1;
                else if (D > 0)
                    p++;
                else
                    p--;
            return 0;
        } else
            return 0;
    else {
        if (a <= n / 2) {
            m = (m > n / 2 - a + 1) ? (n / 2 - a + 1) : m;
            short *p = A + (n / 2) * n + n / 2;
            for (int i = 0; i < m; i++) {
                if (y > 0) {
                    if (i)
                        p -= n;
                    else
                        p -= a * n;
                } else {
                    if (i)
                        p += n;
                    else
                        p += a * n;
                }
                if (*p)
                    return 1;
            }
            return 0;
        } else
            return 0;
    }
}

short Judge(int x1, int y1, int x2, int y2, short a, short b, short n, short *A) {
    int X = abs(x2 - x1), Y = abs(y2 - y1);
    if (X + Y < a)
        if ((X <= n / 2) && (Y <= n / 2)) {
            if (*(A + (n / 2 - (y2 - y1)) * n + n / 2 + x2 - x1))
                return 1;
            else
                return 0;
        } else
            return 0;
    else if ((X + Y >= a) && (X + Y < b)) {
        for (int i = -X; i <= X; i++)
            if (x2 - x1 >= 0) {
                if (Search(-1, x2 - x1 - abs(i), y2 - y1 + i, a, n, X + 1 - abs(i), A))
                    return 1;
            } else {
                if (Search(1, x2 - x1 + abs(i), y2 - y1 + i, a, n, X + 1 - abs(i), A))
                    return 1;
            }
        if (Y > X + a) {
            if (Search(0, x2 - x1, y2 - y1, a, n, Y - X - a + 1, A))
                return 1;
            else
                return 0;
        }
        return 0;
    } else {
        if ((X <= n / 2) && (Y <= n / 2) && (*(A + (n / 2 - (y2 - y1)) * n + n / 2 + x2 - x1)))
            return 1;
        for (short *p = A; p <= A + (n / 2) * n; p += n)
            if (b > a)
                for (short *q = p; (q <= p + n / 2) && ((p - A) / n + (q - p) <= n - 1 - a); q++) {
                    if ((*q) && ((p - A) / n + (q - p) != n - 1 - b))
                        return 1;
                }
            else
                for (short *q = p; (q <= p + n / 2) && ((p - A) / n + (q - p) < n - 1 - b); q++) {
                    if (*q)
                        return 1;
                }
        return 0;
    }
}

int main() {
    short T = 0;
    scanf("%hu", &T);
    for (int t = 0; t < T; t++) {
        int x1 = 0, y1 = 0, x2 = 0, y2 = 0;
        short a = 0, b = 0;
        unsigned short n = 0;
        scanf("%u%u%u%u%hd%hd", &x1, &y1, &x2, &y2, &a, &b);
        scanf("%hu", &n), getchar();
        short A[n][n];
        for (short *p = A[0]; p < A[0] + n * n; p++)
            *p = 0;
        for (short *p = A[0]; p < A[0] + n * n; p += n) {
            for (short *q = p; q < p + n; q++)
                if ((getchar()) == '*')
                    *q = 1, *(A[0] + (n - 1 - (q - p)) * n + (p - A[0]) / n) = 1,
                    *(A[0] + (q - p) * n + n - 1 - (p - A[0]) / n) = 1,
                    *(A[0] + (n - 1 - (p - A[0]) / n) * n + n - 1 - (q - p)) = 1;
                else if (!(*q))
                    *q = 0;
            getchar();
        }
        if (Judge(x1, y1, x2, y2, a, b, (short) n, A[0]))
            printf("YES\n");
        else
            printf("NO\n");
    }
    return 0;
}
