/*
第1关：解铃还须系铃人

任务描述
本关任务：编写一个代码程序解决解铃还须系铃人问题。

相关知识
小明喜欢看谍战片，特别是喜欢看破译电报的桥段。现在他学了C语言，他想借助电脑，将自己的一些文档进行加密。不过有一次在整理硬盘的时候，他不小心把源文档给删掉了。只留下了加密后的文档。当然直接看加密的文档是看不出他写的是什么，不过小明还记得自己是怎么加密的，规律如下：

A→Z,a→z

B→Y,b→y

C→X,c→x

…

Z→A,z→a

即第i个字母变成第（26-i+1）个字母。简单归纳该方法为对称转换加密。

按照上述规律转换，非字母字符不变。例如“China!”转换为“Xsrmz!”

现在小明需要破译自己的文档，为了测试自己的程序的正确性，小明只破译一行字符！
输入描述
输入一行加密后的字符串，长度<10,000

输出描述
输出破译的字符串，注意请不要遗漏任何字符和输出多余的字符

编程要求
根据提示，在右侧编辑器补充代码，编写一个代码程序解决解铃还须系铃人问题。

测试用例
平台会对你编写的代码进行测试：

测试输入：R droo erhrg Xsrmz mvcg dvvp.
预期输出：R droo erhrg Xsrmz mvcg dvvp.
*/

#include <stdio.h>
#include <stdlib.h>

int main()
{
    int n=0;
    char A[10001]= {'\0'};
    //gets(A);
    fgets(A,10001,stdin);
    for(int i=1E4; i>=0; i--)
    {
        if(A[i])
        {
            n=i;
            break;
        }
    }
    for(int i=0; i<=n; i++)
    {
        if((A[i]-'A'>=0)&&(A[i]-'A'<=25))
            A[i]='A'-1+26-(A[i]-'A'+1)+1;
        else if((A[i]-'a'>=0)&&(A[i]-'a'<=25))
            A[i]='a'-1+26-(A[i]-'a'+1)+1;
    }
    for(int i=0; i<=n; i++)
        printf("%c",A[i]);
    return 0;
}
