/*
第5关：抛硬币

任务描述
本关任务：编写一个代码程序解决抛硬币问题。

相关知识
其实，小明有一个小秘密，那就是暗恋计算机系的一个女生很久了。但是又不知道那个女生是怎么想的。3.7女生节就要到了，小明一直在纠结要不要跟那个女生表白。思来想去没有结果。于是乎他觉得采用最原始的办法——抛硬币来决定。正面表白，反面继续沉默观望。不过就像《爱情公寓3》结尾曾小贤说的那样“当面对两个选择时，抛硬币总能奏效，并不是因为它总能给出对的答案，而是在你把它抛在空中的那一秒里，你突然知道你希望它是什么！”呃呃呃，扯远了，其实当硬币还停留在空中的时候，小明想知道的却是：如果我连续抛N次，那么不连续出现正面的可能情况有多少种（即任何相邻两次都不全是正面）？哎，也许这就是作为工科生的思维吧！

请你帮小明写一个程序，输出所有的可能情况（用0表示反面，1表示正面）。

提示：任何一个合法序列的特征是不存在2个1相邻，例如N=4，可行的有0000，0001，0010，0100，0101，1000，1001，1010，共8种。

提示：你提交的代码将被插入到以下程序框架中一起编译，请不要提交全部代码。

 //********** Begin **********
//固定头部开始
#include<stdio.h>
//固定头部结束
//你的代码开始
//你的代码结束
//********** End **********
//主函数固定
int main ()
{
    int i,j;
    scanf("%d",&n);
    for(i=0;i<=1;i++)
        dfs(i,1);
    printf("%d",count);
}
输入描述
输入只有一行一个整数N，表示抛N次硬币。（1≤N≤14）

输出描述
输出有M+1行。

前M行输出每一种可能情况，不同情况按照字典序从小到大排列。

最后一行输出一个数字M，表示不连续出现正面的可能情况的总数。
编程要求
根据提示，在右侧编辑器补充代码，编写一个代码程序解决抛硬币问题。

测试用例
平台会对你编写的代码进行测试：

测试输入：4；
预期输出：
0000
0001
0010
0100
0101
1000
1001
1010
8
*/

//********** Begin **********
//固定头部开始
#include<stdio.h>
//固定头部结束
//你的代码开始
//int n=0,count=1;
//int n=0,count=0;
int n=0,count=0;
char res[15]= {0};

/*
void dfs(int s,int p)
{
    if(s)
    {
        char A[n+1];
        A[n]=0;
        */
/*
for(int i=0; i<n; i++)
    A[i]='0';
    */
/*
for(char *p=A; p<A+n; p++)
*p='0';
*/
/*
printf("%s\n",A);
for(;;)
{
int k=1;
A[n-1]+=1;
for(int i=n-1; i>0; i--)
{
    if(A[i]=='2')
        A[i]='0',A[i-1]+=1;
}
if(A[0]=='2')
    break;
for(int i=1; i<n; i++)
{
    if((A[i]=='1')&&((A[i-1]=='1')||(A[i+1]=='1')))
    {
        k=0;
        break;
    }
}
if(k)
    printf("%s\n",A),count++;
}
*/
/*
int k=1;
while(A[0]!='2')
{
    if(k)
        printf("%s\n",A),count++;
    A[n-1]+=1;
    k=1;
    for(char *p=A+n-1; p>A; p--)
    {
        if(*p=='2')
            *p='0',*(p-1)+=1;
    }
    for(char *p=A+1; p<A+n; p++)
    {
        if((*p=='1')&&((*(p-1)=='1')||(*(p+1)=='1')))
        {
            k=0;
            break;
        }
    }
}
}
}
*/

int dfs(int p,int m)
{
    res[m-1]=p+'0';
    if(m<n)
    {
        dfs(0,m+1);
        if(!p)
            dfs(1,m+1);
    }
    else
        printf("%s\n",res),count++;
    return 0;
}
//你的代码结束
//********** End **********
//主函数固定
int main ()
{
    int i,j;
    scanf("%d",&n);
    for(i=0; i<=1; i++)
        dfs(i,1);
    printf("%d",count);
}
